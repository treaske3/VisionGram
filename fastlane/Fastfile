# fastlane/Fastfile
default_platform(:ios)

platform :ios do
  desc "CI: build and upload to TestFlight"
  lane :ci_beta do
    # ---------- Paths ----------
    ROOT    = File.expand_path("..", __dir__)             # repo root (one up from fastlane/)
    IOS_DIR = File.join(ROOT, "ios")
    PODFILE = File.join(IOS_DIR, "Podfile")

    # ---------- Keychain for CI ----------
    pw = ENV["CI_KEYCHAIN_PW"] || "visiongram_ci_#{Time.now.to_i}_#{rand(1000..9999)}"
    create_keychain(
      name: "ci_keychain",
      password: pw,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    # ---------- App Store Connect API key ----------
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_API_KEY_P8"],
      is_key_content_base64: false,
      in_house: false
    )

    # ---------- Ensure ios/ exists (Expo prebuild fallback) ----------
    unless Dir.exist?(IOS_DIR)
      UI.important("No ios/ folder found — running Expo prebuild fallback…")
      sh(%Q{bash -lc 'cd "#{ROOT}" && npx expo prebuild -p ios --no-install --clean'})
      UI.user_error!("Expo prebuild did not create ios/") unless Dir.exist?(IOS_DIR)
    end

    # ---------- Idempotent Podfile patch ----------
    if File.exist?(PODFILE)
      contents = File.read(PODFILE)

      # Remove unsupported privacy flag if present
      contents = contents.gsub(/.*privacy_file_aggregation_enabled.*\n/, "")

      # Remove any existing jsinspector lines to avoid duplicates
      contents = contents.gsub(/.*React-jsinspector.*\n/, "")

      # Ensure use_modular_headers! once (insert after platform line)
      unless contents.include?("use_modular_headers!")
        lines = contents.lines
        idx = lines.index { |l| l.strip.start_with?("platform ") } || 0
        lines.insert(idx + 1, "\nuse_modular_headers!\n")
        contents = lines.join
      end

      # Choose jsinspector path for RN 0.74+ (modern) or fallback
      js_modern = "../node_modules/react-native/ReactCommon/jsinspector-modern"
      js_old    = "../node_modules/react-native/ReactCommon/jsinspector"
      js_path   = Dir.exist?(File.join(IOS_DIR, js_modern)) ? js_modern : js_old

      # Append one modular-headers definition if not present
      unless contents.include?("pod 'React-jsinspector'")
        contents << "\n  pod 'React-jsinspector', :path => '#{js_path}', :modular_headers => true\n"
      end

      File.write(PODFILE, contents)
    else
      UI.user_error!("Podfile not found at #{PODFILE}")
    end

    # ---------- Install Pods ----------
    sh(%Q{bash -lc 'cd "#{IOS_DIR}" && pod repo update'})
    sh(%Q{bash -lc 'cd "#{IOS_DIR}" && pod install --repo-update'})

    # ---------- Signing: set Team + Automatic for Release ----------
    update_project_team(
      path: File.join(IOS_DIR, "VisionGram.xcodeproj"),
      teamid: ENV["TEAM_ID"],
      targets: ["VisionGram"]
    )

    update_code_signing_settings(
      path: File.join(IOS_DIR, "VisionGram.xcodeproj"),
      use_automatic_signing: true,
      team_id: ENV["TEAM_ID"],
      code_sign_identity: "Apple Distribution",
      build_configurations: ["Release"],
      targets: ["VisionGram"]
    )

    # ---------- Build with explicit profile mapping ----------
    xcworkspace = Dir[File.join(IOS_DIR, "*.xcworkspace")].first
    UI.user_error!("No .xcworkspace found in ios/") unless xcworkspace

    scheme_name = ENV["IOS_SCHEME"] || "VisionGram"

    # Hardcode the App Store provisioning profile name
    profile_name = "VisionGram App Store Profile"

    build_ios_app(
      workspace: xcworkspace,
      scheme: scheme_name,
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      xcargs: "-allowProvisioningUpdates",
      export_options: {
        provisioningProfiles: {
          ENV["APP_IDENTIFIER"] => profile_name
        }
      }
    )

    upload_to_app_store(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      reject_if_possible: false,
      submit_for_review: false
    )
  ensure
    # Always try to clean up the CI keychain
    begin
      delete_keychain(name: "ci_keychain")
    rescue => e
      UI.important("Keychain cleanup warning: #{e.class} - #{e.message}")
    end
  end
end
