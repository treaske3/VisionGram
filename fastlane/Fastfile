default_platform(:ios)

platform :ios do
  desc "CI: build and upload to TestFlight"
  lane :ci_beta do
    # --- Keychain password (from secret or generated) ---
    pw = ENV["CI_KEYCHAIN_PW"] || "visiongram_ci_#{Time.now.to_i}_#{rand(1000..9999)}"

    create_keychain(
      name: "ci_keychain",
      password: pw,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    # Ensure native iOS project exists (fallback guard if workflow missed prebuild)
    unless Dir.exist?("ios")
      UI.important("No ios/ folder found — running Expo prebuild fallback…")
      sh("npx expo prebuild -p ios --no-install --clean")
      UI.user_error!("Expo prebuild did not create ios/") unless Dir.exist?("ios")
    end

    # Ensure Pods/workspace exist (self-heal & idempotent patch)
    unless File.exist?("ios/Pods") || Dir["ios/*.xcworkspace"].any?
      UI.important("No Pods/.xcworkspace — patching Podfile and installing pods…")
      Dir.chdir("ios") do
        # Remove unsupported privacy flag (if present)
        sh(%q{sedi() { sed -i '' "$1" "$2" 2>/dev/null || sed -i "$1" "$2"; }; sedi '/privacy_file_aggregation_enabled/d' Podfile || true})

        # Remove ALL existing React-jsinspector lines (avoid duplicates)
        sh(%q{sedi() { sed -i '' "$1" "$2" 2>/dev/null || sed -i "$1" "$2"; }; sedi '/React-jsinspector/d' Podfile || true})

        # Ensure use_modular_headers! exists (insert after platform once)
        patch = <<~'AWK'
          BEGIN{added=0}
          /^platform/ && added==0 {print; print ""; print "use_modular_headers!"; added=1; next}
          {print}
        AWK
        unless File.read("Podfile").include?("use_modular_headers!")
          File.write("Podfile.tmp", IO.popen(%Q{awk '#{patch.gsub("\n","\\n")}' Podfile}, &:read))
          File.rename("Podfile.tmp", "Podfile")
        end

        # Choose correct jsinspector path (RN 0.74+: jsinspector-modern)
        js_modern = "../node_modules/react-native/ReactCommon/jsinspector-modern"
        js_old    = "../node_modules/react-native/ReactCommon/jsinspector"
        js_path   = Dir.exist?(js_modern) ? js_modern : js_old

        # Append ONE modular-headers definition
        File.open("Podfile", "a") do |f|
          f.puts "  pod 'React-jsinspector', :path => '#{js_path}', :modular_headers => true"
        end

        sh("pod repo update")
        sh("pod install --repo-update")
      end
    end

    # App Store Connect API key (no interactive login)
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_API_KEY_P8"],
      is_key_content_base64: false,
      in_house: false
    )

    # Prefer match; fall back to automatic signing if it can't access the repo
    begin
      UI.message("Attempting signing via match…")
      match(
        type: "appstore",
        readonly: false,
        git_url: ENV["MATCH_GIT_URL"],
        git_basic_authorization: ENV["MATCH_GIT_BASIC_AUTHORIZATION"],
        storage_mode: "git",
        app_identifier: [ENV["APP_IDENTIFIER"]],
        keychain_name: "ci_keychain",
        keychain_password: pw,
        verbose: true
      )
    rescue => e
      UI.important("match failed or unavailable: #{e.class} - #{e.message}")
      UI.important("Continuing with Xcode automatic signing (-allowProvisioningUpdates)…")
    end

    # Build without changing directories; use workspace under ios/
    xcworkspace = Dir["ios/*.xcworkspace"].first
    UI.user_error!("No .xcworkspace found in ios/") unless xcworkspace

    scheme_name = ENV["IOS_SCHEME"] || "VisionGram"

    build_ios_app(
      workspace: xcworkspace,
      scheme: scheme_name,
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      xcargs: "-allowProvisioningUpdates"
    )

    upload_to_app_store(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      reject_if_possible: false,
      submit_for_review: false
    )
  ensure
    begin
      delete_keychain(name: "ci_keychain")
    rescue => e
      UI.important("Keychain cleanup warning: #{e.class} - #{e.message}")
    end
  end
end
