# fastlane/Fastfile
default_platform(:ios)

platform :ios do
  desc "CI: build and upload to TestFlight"
  lane :ci_beta do
    require "open3"
    # ---------- Paths ----------
    ROOT    = File.expand_path("..", __dir__)             # repo root (one up from fastlane/)
    IOS_DIR = File.join(ROOT, "ios")
    PODFILE = File.join(IOS_DIR, "Podfile")

    # ---------- Keychain for CI ----------
    pw = ENV["CI_KEYCHAIN_PW"] || "visiongram_ci_#{Time.now.to_i}_#{rand(1000..9999)}"
    create_keychain(
      name: "ci_keychain",
      password: pw,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    # ---------- App Store Connect API key ----------
    api_key = app_store_connect_api_key(
      key_id: ENV["ASC_KEY_ID"],
      issuer_id: ENV["ASC_ISSUER_ID"],
      key_content: ENV["ASC_API_KEY_P8"],
      is_key_content_base64: false,
      in_house: false
    )

    # ---------- Ensure ios/ exists (Expo prebuild fallback) ----------
    unless Dir.exist?(IOS_DIR)
      UI.important("No ios/ folder found — running Expo prebuild fallback…")
      sh(%Q{bash -lc 'cd "#{ROOT}" && npx expo prebuild -p ios --no-install --clean'})
      UI.user_error!("Expo prebuild did not create ios/") unless Dir.exist?(IOS_DIR)
    end

    # ---------- Idempotent Podfile patch ----------
    if File.exist?(PODFILE)
      contents = File.read(PODFILE)

      # Remove unsupported privacy flag if present
      contents = contents.gsub(/.*privacy_file_aggregation_enabled.*\n/, "")

      # Remove any existing jsinspector lines to avoid duplicates
      contents = contents.gsub(/.*React-jsinspector.*\n/, "")

      # Ensure use_modular_headers! once (insert after platform line)
      unless contents.include?("use_modular_headers!")
        lines = contents.lines
        idx = lines.index { |l| l.strip.start_with?("platform ") } || 0
        lines.insert(idx + 1, "\nuse_modular_headers!\n")
        contents = lines.join
      end

      # Choose jsinspector path for RN 0.74+ (modern) or fallback
      js_modern = "../node_modules/react-native/ReactCommon/jsinspector-modern"
      js_old    = "../node_modules/react-native/ReactCommon/jsinspector"
      js_path   = Dir.exist?(File.join(IOS_DIR, js_modern)) ? js_modern : js_old

      # Append one modular-headers definition if not present
      unless contents.include?("pod 'React-jsinspector'")
        contents << "\n  pod 'React-jsinspector', :path => '#{js_path}', :modular_headers => true\n"
      end

      File.write(PODFILE, contents)
    else
      UI.user_error!("Podfile not found at #{PODFILE}")
    end

    # ---------- Install Pods ----------
    sh(%Q{bash -lc 'cd "#{IOS_DIR}" && pod repo update'})
    sh(%Q{bash -lc 'cd "#{IOS_DIR}" && pod install --repo-update'})

    # ---------- Signing: set Team + Automatic for Release ----------
    update_project_team(
      path: File.join(IOS_DIR, "VisionGram.xcodeproj"),
      teamid: ENV["TEAM_ID"],
      targets: ["VisionGram"]
    )

    update_code_signing_settings(
      path: File.join(IOS_DIR, "VisionGram.xcodeproj"),
      use_automatic_signing: true,
      team_id: ENV["TEAM_ID"],
      code_sign_identity: "Apple Distribution",
      build_configurations: ["Release"],
      targets: ["VisionGram"]
    )

    # ---------- Resolve provisioning profile name ----------
    profiles_dir = File.expand_path("~/Library/MobileDevice/Provisioning Profiles")
    scheme_name  = ENV["IOS_SCHEME"] || "VisionGram"

    # Prefer the workflow-imported value
    profile_name = ENV["PROFILE_NAME"].to_s.strip

    # If missing, auto-discover an installed App Store profile matching the bundle id
    if profile_name.empty?
      UI.message("PROFILE_NAME not set; attempting discovery under #{profiles_dir} …")
      Dir[File.join(profiles_dir, "*.mobileprovision")].each do |f|
        plist, _ = Open3.capture2(%Q{/usr/bin/security cms -D -i "#{f}" | plutil -convert xml1 -o - -})
        next if plist.to_s.strip.empty?

        name,  _ = Open3.capture2(%q{/usr/libexec/PlistBuddy -c "Print :Name" /dev/stdin},  stdin_data: plist)
        appid, _ = Open3.capture2(%q{/usr/libexec/PlistBuddy -c "Print :Entitlements:application-identifier" /dev/stdin}, stdin_data: plist)
        type,  _ = Open3.capture2(%q{/usr/libexec/PlistBuddy -c "Print :ProvisionsAllDevices" /dev/stdin}, stdin_data: plist) rescue ["", nil]

        name  = name.to_s.strip
        appid = appid.to_s.strip

        # Must target our bundle id (TEAM_ID.bundleid or *.bundleid)
        matches_bundle = (appid == "#{ENV['TEAM_ID']}.#{ENV['APP_IDENTIFIER']}") || appid.end_with?(".#{ENV['APP_IDENTIFIER']}")
        # Ensure it's an App Store (not AdHoc/Development); ProvisionsAllDevices is nil/false for App Store
        is_app_store = (type.to_s.strip.empty? || type.to_s.strip == "false")

        if matches_bundle && is_app_store
          profile_name = name
          UI.message("Auto-discovered provisioning profile: #{profile_name}")
          break
        end
      end
    end

    UI.user_error!(
      "Could not resolve provisioning profile name. " \
      "Confirm the import step ran and the profile targets #{ENV['APP_IDENTIFIER']}."
    ) if profile_name.to_s.strip.empty?

    # ---------- Build & Upload ----------
    xcworkspace = Dir[File.join(IOS_DIR, "*.xcworkspace")].first
    UI.user_error!("No .xcworkspace found in ios/") unless xcworkspace

    build_ios_app(
      workspace: xcworkspace,
      scheme: scheme_name,
      configuration: "Release",
      export_method: "app-store",
      clean: true,
      xcargs: "-allowProvisioningUpdates",
      export_options: {
        provisioningProfiles: {
          ENV["APP_IDENTIFIER"] => profile_name
        }
      }
    )

    upload_to_app_store(
      api_key: api_key,
      skip_screenshots: true,
      skip_metadata: true,
      reject_if_possible: false,
      submit_for_review: false
    )
  ensure
    # Always try to clean up the CI keychain
    begin
      delete_keychain(name: "ci_keychain")
    rescue => e
      UI.important("Keychain cleanup warning: #{e.class} - #{e.message}")
    end
  end
end
